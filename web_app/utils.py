import json
import os
import tempfile
from pathlib import Path
from typing import IO

from asammdf import MDF
import streamlit as st


@st.cache_resource
def load_mdf(file_buffer: IO[bytes]) -> tuple[MDF, str]:
    """
    Saves the uploaded file buffer to a temporary file and initializes the MDF object.
    Using a temporary file allows MDF to lazily load data, which is more memory efficient
    than loading everything into RAM.
    """
    # Create a temporary file
    # We need to delete=False because we need the path to persist for MDF to open it
    # We should handle cleanup eventually, but for this session-based approach, system cache might handle it
    # or we can track it in session state to delete later.
    suffix = Path(file_buffer.name).suffix
    with tempfile.NamedTemporaryFile(delete=False, suffix=suffix) as tmp_file:
        tmp_file.write(file_buffer.read())
        tmp_path = tmp_file.name

    try:
        mdf = MDF(tmp_path)
        return mdf, tmp_path
    except Exception as e:
        # If loading fails, we should try to clean up the temp file immediately
        if os.path.exists(tmp_path):
            os.remove(tmp_path)
        raise e


def load_dspf(file_buffer: IO[bytes]) -> list[str]:
    """
    Parses a .dspf file (JSON format) and extracts channel names from configuration windows.
    """
    channels = []
    try:
        # .dspf is essentially JSON with some custom encoding potentially,
        # but asammdf usually treats it as JSON.
        # We need to handle potential null bytes or encoding issues if generated by standard tools.
        content = file_buffer.read()
        # Remove null bytes if any (common in some MDF tool exports)
        content = content.replace(b"\x00", b"")
        text = content.decode("utf-8", errors="replace")

        info = json.loads(text)

        windows = info.get("windows", [])
        for window in windows:
            # We are interested in channels from Plot, Numeric, and Tabular windows
            w_type = window.get("type")
            config = window.get("configuration", {})
            window_channels = config.get("channels", [])

            if w_type == "Plot":
                # For Plot, channels structure might be nested groups or list of dicts/strings
                # Based on serde.py flatten_dsp logic:
                # We need a helper to flatten if it's recursive
                channels.extend(_flatten_dsp_channels(window_channels))

            elif w_type in ("Numeric", "Tabular"):
                # Usually a list of dicts with 'name' key, or just strings?
                # In serde.py: [item["name"] for item in ...]
                for item in window_channels:
                    if isinstance(item, dict):
                        channels.append(item.get("name", ""))
                    elif isinstance(item, str):
                        channels.append(item)

    except Exception as e:
        st.error(f"Failed to parse DSPF file: {e}")
        return []

    return sorted(list(set(channels)))


def _flatten_dsp_channels(channels_data: list) -> list[str]:
    """Helper to flatten DSPF channel structure."""
    res = []
    for item in channels_data:
        if isinstance(item, dict):
            if item.get("type") == "group":
                res.extend(_flatten_dsp_channels(item.get("channels", [])))
            else:
                res.append(item.get("name", ""))
        elif isinstance(item, str):
            res.append(item)
    return res
